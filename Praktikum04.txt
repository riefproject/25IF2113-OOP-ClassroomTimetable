package id.ac.polban.app;

import id.ac.polban.service.Seed;
import java.io.IOException;

public class Main {

    public static void main(String[] args) {
        Seed seed;
        try {
            seed = Seed.loadFromCsvs("data");
        } catch (IOException e) {
            System.err.println("FATAL: Gagal membaca data dari direktori 'data'. Aplikasi tidak dapat berjalan.");
            System.err.println("Detail Error: " + e.getMessage());
            e.printStackTrace();
            return;
        }

        MenuApp menu = new MenuApp(seed);
        menu.run();
    }
}
package id.ac.polban.app;

import id.ac.polban.contract.Displayable;
import id.ac.polban.model.*;
import id.ac.polban.service.JadwalSearch;
import id.ac.polban.service.Seed;

import java.util.*;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.stream.Collectors;

public class MenuApp {
    private final Seed data;
    private final Scanner scanner;
    private final Map<String, Consumer<String[]>> menuActions;

    public MenuApp(Seed data) {
        this.data = data;
        this.scanner = new Scanner(System.in);
        this.menuActions = new HashMap<>();
        initializeMenuActions();
    }


    private void initializeMenuActions() {
        menuActions.put("1", this::navigateToMahasiswa);
        menuActions.put("2", this::navigateToDosen);
        menuActions.put("3", this::navigateToMataKuliah);
        menuActions.put("4", this::navigateToJadwal);
    }

    public void run() {
        while (true) {
            displayMainMenu();
            String input = scanner.nextLine().trim();
            if (input.equalsIgnoreCase("0") || input.equalsIgnoreCase("exit")) {
                System.out.println("Terima kasih telah menggunakan aplikasi. Sampai jumpa!");
                break;
            }
            handleMainMenu(input);
        }
        scanner.close();
    }

    private void displayMainMenu() {
        System.out.println("\n=================================================");
        System.out.println("   Sistem Informasi Akademik Politeknik Bandung");
        System.out.println("=================================================");
        System.out.println("Menu Utama:");
        System.out.println("1. Tampilkan Mahasiswa");
        System.out.println("2. Tampilkan Dosen");
        System.out.println("3. Tampilkan Mata Kuliah");
        System.out.println("4. Tampilkan Jadwal Kuliah");
        System.out.println("0. Keluar");
        System.out.println("-------------------------------------------------");
        System.out.print("Pilih menu (bisa dengan shorthand, cth: '1 JTK D3-TI'): ");
    }

    private void handleMainMenu(String input) {
        if (input.isEmpty()) {
            System.out.println("Input tidak boleh kosong.");
            return;
        }
        String[] parts = input.split("\\s+");
        String command = parts[0];
        String[] args = Arrays.copyOfRange(parts, 1, parts.length);
        Consumer<String[]> action = menuActions.get(command);
        if (action != null) {
            action.accept(args);
        } else {
            System.out.println("Pilihan menu tidak valid. Silakan coba lagi.");
        }
    }

    // --- ALUR NAVIGASI ---

    private void navigateToMahasiswa(String[] args) {
        Jurusan jurusan = selectionPrompt("Jurusan", data.getJurusan(), Jurusan::getName, Jurusan::getAlias, args, 0);
        if (jurusan == null) return;
        Prodi prodi = selectionPrompt("Program Studi", jurusan.getProdiList(), p -> p.getJenjang() + " " + p.getName(), Prodi::getAlias, args, 1);
        if (prodi == null) return;
        Kelas kelas = selectionPrompt("Kelas", prodi.getClassList(), Kelas::getCode, null, args, 2);
        if (kelas == null) return;
        displayList("Daftar Mahasiswa Kelas " + kelas.getCode(), kelas.getMahasiswaList());
    }

    private void navigateToJadwal(String[] args) {
        Jurusan jurusan = selectionPrompt("Jurusan", data.getJurusan(), Jurusan::getName, Jurusan::getAlias, args, 0);
        if (jurusan == null) return;
        Prodi prodi = selectionPrompt("Program Studi", jurusan.getProdiList(), p -> p.getJenjang() + " " + p.getName(), Prodi::getAlias, args, 1);
        if (prodi == null) return;
        Kelas kelas = selectionPrompt("Kelas", prodi.getClassList(), Kelas::getCode, null, args, 2);
        if (kelas == null) return;
        
        // REFACTOR: Panggil search, lalu hasilnya lempar ke displayList
        List<Jadwal> jadwalList = JadwalSearch.searchByKelas(data, kelas.getCode(), "all");
        displayList("Jadwal Kuliah Kelas " + kelas.getCode(), jadwalList);
    }

    private void navigateToDosen(String[] args) {
        Jurusan jurusan = selectionPrompt("Jurusan", data.getJurusan(), Jurusan::getName, Jurusan::getAlias, args, 0);
        if (jurusan == null) return;
        Prodi prodi = selectionPrompt("Program Studi", jurusan.getProdiList(), p -> p.getJenjang() + " " + p.getName(), Prodi::getAlias, args, 1);
        if (prodi == null) return;
        Set<Dosen> uniqueDosen = new HashSet<>();
        prodi.getCourseList().forEach(mk -> uniqueDosen.addAll(mk.getPengampuList()));
        displayList("Daftar Dosen Prodi " + prodi.getName(), new ArrayList<>(uniqueDosen));
    }

    private void navigateToMataKuliah(String[] args) {
        Jurusan jurusan = selectionPrompt("Jurusan", data.getJurusan(), Jurusan::getName, Jurusan::getAlias, args, 0);
        if (jurusan == null) return;
        Prodi prodi = selectionPrompt("Program Studi", jurusan.getProdiList(), p -> p.getJenjang() + " " + p.getName(), Prodi::getAlias, args, 1);
        if (prodi == null) return;
        List<MataKuliah> filteredMataKuliah = data.getMataKuliah().stream()
                .filter(mk -> mk.getCourseType() == CourseType.UMUM || mk.getProdiList().contains(prodi))
                .collect(Collectors.toList());
        displayList("Daftar Mata Kuliah Prodi " + prodi.getName(), filteredMataKuliah);
    }

    // --- HELPER TAMPILAN & INPUT ---

    private <T extends Displayable> void displayList(String title, List<T> items) {
        System.out.println("\n--- " + title + " ---");
        if (items.isEmpty()) {
            System.out.println("Tidak ada data yang tersedia.");
            waitForEnter();
            return;
        }

        List<String> headers = items.get(0).getTableHeader();
        List<List<String>> rows = items.stream().map(Displayable::getTableRowData).collect(Collectors.toList());
        int numColumns = headers.size();

        List<Integer> columnWidths = new ArrayList<>();
        for (int i = 0; i < numColumns; i++) {
            int maxWidth = headers.get(i).length();
            for (List<String> row : rows) {
                if (row.get(i).length() > maxWidth) {
                    maxWidth = row.get(i).length();
                }
            }
            columnWidths.add(maxWidth);
        }

        StringBuilder format = new StringBuilder("|");
        for (Integer width : columnWidths) {
            format.append(" %-").append(width).append("s |");
        }
        format.append("\n");

        StringBuilder separator = new StringBuilder("+");
        for (Integer width : columnWidths) {
            separator.append("-".repeat(width + 2)).append("+");
        }

        System.out.println(separator);
        System.out.printf(format.toString(), headers.toArray());
        System.out.println(separator);
        for (List<String> row : rows) {
            System.out.printf(format.toString(), row.toArray());
        }
        System.out.println(separator);
        System.out.println("Total: " + items.size() + " data.");

        waitForEnter();
    }

    private <T> T selectionPrompt(String entityName, List<T> items, Function<T, String> nameExtractor, Function<T, String> aliasExtractor, String[] args, int argIndex) {
        if (argIndex < args.length) {
            Optional<T> found = findItemByNameOrAlias(args[argIndex], items, nameExtractor, aliasExtractor);
            if (found.isPresent()) return found.get();
            System.out.printf("Shorthand '%s' untuk %s tidak ditemukan. Pilih manual.%n", args[argIndex], entityName);
        }
        while (true) {
            System.out.printf("%n--- Pilih %s ---%n", entityName);
            if (items.isEmpty()) {
                System.out.printf("Tidak ada data %s yang tersedia.%n", entityName);
                waitForEnter();
                return null;
            }
            for (int i = 0; i < items.size(); i++) {
                String name = nameExtractor.apply(items.get(i));
                String alias = (aliasExtractor != null && aliasExtractor.apply(items.get(i)) != null) ? " (" + aliasExtractor.apply(items.get(i)) + ")" : "";
                System.out.printf("%d. %s%s%n", i + 1, name, alias);
            }
            System.out.println("0. Kembali");
            System.out.print("Pilih nomor atau ketik nama/alias: ");
            String input = scanner.nextLine().trim();
            if (input.equalsIgnoreCase("0") || input.equalsIgnoreCase("kembali")) return null;
            Optional<T> found = findItemFromManualInput(input, items, nameExtractor, aliasExtractor);
            if (found.isPresent()) {
                return found.get();
            } else {
                System.out.printf("Input '%s' tidak dikenali. Coba lagi.%n", input);
            }
        }
    }

    private <T> Optional<T> findItemFromManualInput(String input, List<T> items, Function<T, String> nameExtractor, Function<T, String> aliasExtractor) {
        try {
            int choice = Integer.parseInt(input);
            if (choice > 0 && choice <= items.size()) {
                return Optional.of(items.get(choice - 1));
            }
        } catch (NumberFormatException e) {
            // Lanjut
        }
        return findItemByNameOrAlias(input, items, nameExtractor, aliasExtractor);
    }

    private <T> Optional<T> findItemByNameOrAlias(String input, List<T> items, Function<T, String> nameExtractor, Function<T, String> aliasExtractor) {
        return items.stream()
                .filter(item -> {
                    boolean nameMatch = nameExtractor.apply(item).equalsIgnoreCase(input);
                    boolean aliasMatch = aliasExtractor != null && aliasExtractor.apply(item) != null && aliasExtractor.apply(item).equalsIgnoreCase(input);
                    return nameMatch || aliasMatch;
                })
                .findFirst();
    }

    private void waitForEnter() {
        System.out.print("\nTekan Enter untuk melanjutkan...");
        scanner.nextLine();
    }
}
package id.ac.polban.contract;

public interface Activable {
    void activate();
    void deactivate();
    boolean isActive();
}
package id.ac.polban.contract;

import java.util.List;

/**
 * Kontrak untuk objek yang datanya bisa ditampilkan dalam format tabel.
 * Ini memisahkan DATA dari PRESENTASI.
 * Objek cuma perlu nyediain data header dan baris, nanti view yg ngatur nampilinnya.
 */
public interface Displayable {
    /**
     * Mengembalikan daftar judul kolom untuk tabel.
     * Contoh: ["NIM", "Nama Mahasiswa", "Status"]
     * @return List of string headers.
     */
    List<String> getTableHeader();

    /**
     * Mengembalikan daftar nilai (sebagai string) untuk satu baris data.
     * Urutannya harus sama persis dengan header.
     * Contoh: ["231511001", "John Doe", "Aktif"]
     * @return List of string row data.
     */
    List<String> getTableRowData();
}package id.ac.polban.contract;

public interface Persistable {
    String toPersistableFormat();
    // void fromPersistableFormat(String data);
}
package id.ac.polban.model;

import id.ac.polban.contract.Displayable;
import id.ac.polban.contract.Persistable;

import java.util.List;
import java.util.Objects;

public abstract class AkademikEntity implements Displayable, Persistable {
    private String code;
    private String name;

    public AkademikEntity(String code, String name) {
        this.code = Objects.requireNonNull(code);
        this.name = Objects.requireNonNull(name);
    }

    // --- Getters & Setters ---
    public String getCode() { return code; }
    public void setCode(String code) { this.code = Objects.requireNonNull(code); }
    public String getName() { return name; }
    public void setName(String name) { this.name = Objects.requireNonNull(name); }

    public String getIdentity() { return code + " - " + name; }

    // --- Implementasi Interface Displayable ---
    @Override
    public abstract List<String> getTableHeader();
    @Override
    public abstract List<String> getTableRowData();

    // --- Implementasi Interface Persistable ---
    @Override
    public String toPersistableFormat() {
        return code + "," + name;
    }

    // --- Override Method Bawaan Java ---
    @Override
    public String toString() { return getIdentity(); }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        AkademikEntity that = (AkademikEntity) o;
        return code.equals(that.code);
    }

    @Override
    public int hashCode() { return code.hashCode(); }
}
package id.ac.polban.model;

public enum CourseType {
    UMUM,
    PRODI_SPECIFIC
}
package id.ac.polban.model;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

public class Dosen extends Person {
    private String email;
    private final List<MataKuliah> mataKuliahDiampu = new ArrayList<>();

    public Dosen(String kodeDosen, String nama, String email) {
        super(kodeDosen, nama); // oper ke parent
        this.email = Objects.requireNonNull(email);
    }

    // --- Getters & Setters ---
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = Objects.requireNonNull(email); }

    // --- Logika bisnis buat ngatur mata kuliah yg diampu ---
    public List<MataKuliah> getMataKuliahDiampu() {
        return Collections.unmodifiableList(mataKuliahDiampu);
    }

    public void ampu(MataKuliah mk) {
        if (mk != null && !mataKuliahDiampu.contains(mk)) {
            mataKuliahDiampu.add(mk);
            mk.tambahPengampu(this);
        }
    }

    public void lepas(MataKuliah mk) {
        if (mk != null && mataKuliahDiampu.remove(mk)) {
            mk.hapusPengampu(this);
        }
    }

    // --- info lebih detail ---
    @Override
    public String getIdentity() {
        return super.getIdentity() + " | " + email;
    }

    // --- Implementasi Displayable ---
    @Override
    public List<String> getTableHeader() {
        return List.of("NIP", "Nama Dosen", "Email", "Status");
    }

    @Override
    public List<String> getTableRowData() {
        return List.of(
            getId(),
            getName(),
            this.email,
            (isActive() ? "Aktif" : "Non-Aktif")
        );
    }

    // --- Implementasi Persistable ---
    @Override
    public String toPersistableFormat() {
        return super.toPersistableFormat() + "," + this.email;
    }
}
package id.ac.polban.model;

import java.time.DayOfWeek;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Objects;
import id.ac.polban.contract.Displayable;
import id.ac.polban.contract.Persistable;

public class Jadwal implements Displayable, Persistable {
    private final Kelas kelas;
    private final MataKuliah mataKuliah;
    private final Dosen dosen;
    private DayOfWeek day;
    private LocalTime startTime;
    private LocalTime endTime;
    private String room;

    public Jadwal(Kelas kelas, MataKuliah mataKuliah, Dosen dosen,
                  DayOfWeek day, LocalTime startTime, LocalTime endTime, String room) {
        this.kelas = Objects.requireNonNull(kelas);
        this.mataKuliah = Objects.requireNonNull(mataKuliah);
        this.dosen = Objects.requireNonNull(dosen);
        this.day = Objects.requireNonNull(day);
        this.startTime = Objects.requireNonNull(startTime);
        this.endTime = Objects.requireNonNull(endTime);
        this.room = Objects.requireNonNull(room);
        kelas.addJadwal(this);
    }

    // --- Getters & Setters ---
    public Kelas getKelas() { return kelas; }
    public MataKuliah getMataKuliah() { return mataKuliah; }
    public Dosen getDosen() { return dosen; }
    public DayOfWeek getDay() { return day; }
    public void setDay(DayOfWeek day) { this.day = Objects.requireNonNull(day); }
    public LocalTime getStartTime() { return startTime; }
    public void setStartTime(LocalTime startTime) { this.startTime = Objects.requireNonNull(startTime); }
    public LocalTime getEndTime() { return endTime; }
    public void setEndTime(LocalTime endTime) { this.endTime = Objects.requireNonNull(endTime); }
    public String getRoom() { return room; }
    public void setRoom(String room) { this.room = Objects.requireNonNull(room); }

    // --- Implementasi Displayable ---
    @Override
    public List<String> getTableHeader() {
        return List.of("Hari", "Waktu", "Mata Kuliah", "Dosen Pengajar", "Ruangan");
    }

    @Override
    public List<String> getTableRowData() {
        DateTimeFormatter timeFormatter = DateTimeFormatter.ofPattern("HH:mm");
        String waktu = startTime.format(timeFormatter) + " - " + endTime.format(timeFormatter);
        return List.of(
            day.toString(), // Nanti bisa diformat lagi di view jika perlu
            waktu,
            mataKuliah.getName(),
            dosen.getName(),
            room
        );
    }

    // --- Implementasi Persistable ---
    @Override
    public String toPersistableFormat() {
        return String.join(",",
                kelas.getCode(), mataKuliah.getCode(), dosen.getId(),
                day.toString(), startTime.toString(), endTime.toString(), room);
    }
}
package id.ac.polban.model;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

public class Jurusan extends AkademikEntity {
    private Kampus kampus;
    private final List<Prodi> prodiList = new ArrayList<>();
    private String alias;

    public Jurusan(String code, String name, Kampus kampus) {
        super(code, name);
        this.kampus = Objects.requireNonNull(kampus);
    }

    public Jurusan(String code, String name, String alias, Kampus kampus) {
        super(code, name);
        this.alias = alias;
        this.kampus = Objects.requireNonNull(kampus);
    }

    // --- Getters & Setters ---
    public String getAlias() { return alias; }
    public void setAlias(String alias) { this.alias = alias; }
    public Kampus getKampus() { return kampus; }
    public void setKampus(Kampus kampus) { this.kampus = Objects.requireNonNull(kampus); }

    // --- Logika Bisnis ---
    public List<Prodi> getProdiList() { return Collections.unmodifiableList(prodiList); }
    public void addProdi(Prodi prodi) {
        if (prodi != null && !prodiList.contains(prodi)) {
            prodiList.add(prodi);
            if (prodi.getJurusan() != this) prodi.setJurusan(this);
        }
    }
    public void removeProdi(Prodi prodi) {
        if (prodi != null && prodiList.remove(prodi)) {
            if (prodi.getJurusan() == this) prodi.setJurusan(null);
        }
    }

    // --- Override untuk Info Lebih Detail ---
    @Override
    public String getIdentity() {
        String base = super.getIdentity();
        String extra = "";
        if (alias != null && !alias.isEmpty()) extra += " | Alias: " + alias;
        if (kampus != null) extra += " | Kampus: " + kampus.getName();
        return base + extra;
    }

    // --- Implementasi Displayable ---
    @Override
    public List<String> getTableHeader() {
        return List.of("Kode Jurusan", "Nama Jurusan", "Alias", "Kampus");
    }

    @Override
    public List<String> getTableRowData() {
        return List.of(
            getCode(),
            getName(),
            (alias != null ? alias : "-"),
            (kampus != null ? kampus.getName() : "-")
        );
    }

    // --- Implementasi Persistable ---
    @Override
    public String toPersistableFormat() {
        String base = super.toPersistableFormat();
        String kampusCode = (kampus != null) ? kampus.getCode() : "null";
        return base + "," + alias + "," + kampusCode;
    }
}
package id.ac.polban.model;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Kampus extends AkademikEntity {
    private final List<Jurusan> jurusanList = new ArrayList<>();
    private String alias;

    public Kampus(String code, String name) {
        super(code, name);
    }

    public Kampus(String code, String name, String alias) {
        super(code, name);
        this.alias = alias;
    }

    // --- Getters & Setters ---
    public String getAlias() { return alias; }
    public void setAlias(String alias) { this.alias = alias; }

    // --- Logika Bisnis ---
    public List<Jurusan> getJurusanList() { return Collections.unmodifiableList(jurusanList); }
    public void addJurusan(Jurusan jurusan) { if (jurusan != null && !jurusanList.contains(jurusan)) jurusanList.add(jurusan); }
    public void removeJurusan(Jurusan jurusan) { jurusanList.remove(jurusan); }

    // --- Override untuk Info Lebih Detail ---
    @Override
    public String getIdentity() {
        String base = super.getIdentity();
        if (alias != null && !alias.isEmpty()) base += " | Alias: " + alias;
        return base + " | Jumlah Jurusan: " + jurusanList.size();
    }

    // --- Implementasi Displayable ---
    @Override
    public List<String> getTableHeader() {
        return List.of("Kode Kampus", "Nama Kampus", "Alias", "Jumlah Jurusan");
    }

    @Override
    public List<String> getTableRowData() {
        return List.of(
            getCode(),
            getName(),
            (alias != null ? alias : "-"),
            String.valueOf(jurusanList.size())
        );
    }

    // --- Implementasi Persistable ---
    @Override
    public String toPersistableFormat() {
        return super.toPersistableFormat() + "," + alias;
    }
}
package id.ac.polban.model;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

public class Kelas extends AkademikEntity {
    private Prodi prodi;
    private final List<Mahasiswa> mahasiswaList = new ArrayList<>();
    private final List<Jadwal> jadwalList = new ArrayList<>();

    public Kelas(String classCode, Prodi prodi) {
        super(classCode, "Kelas " + classCode);
        this.prodi = Objects.requireNonNull(prodi);
    }

    // --- Getters & Setters ---
    public Prodi getProdi() { return prodi; }
    public void setProdi(Prodi prodi) { this.prodi = Objects.requireNonNull(prodi); }

    // --- Logika Bisnis ---
    public List<Mahasiswa> getMahasiswaList() { return Collections.unmodifiableList(mahasiswaList); }
    public void addMahasiswa(Mahasiswa mahasiswa) {
        if (mahasiswa != null && !mahasiswaList.contains(mahasiswa)) {
            mahasiswaList.add(mahasiswa);
            if (mahasiswa.getKelas() != this) mahasiswa.setKelas(this);
        }
    }
    public void removeMahasiswa(Mahasiswa mahasiswa) {
        if (mahasiswaList.remove(mahasiswa) && mahasiswa.getKelas() == this) {
            mahasiswa.setKelas(null);
        }
    }
    public List<Jadwal> getJadwalList() { return Collections.unmodifiableList(jadwalList); }
    void addJadwal(Jadwal jadwal) { if (jadwal != null && !jadwalList.contains(jadwal)) jadwalList.add(jadwal); }
    void removeJadwal(Jadwal jadwal) { jadwalList.remove(jadwal); }

    // --- Implementasi Displayable ---
    @Override
    public List<String> getTableHeader() {
        return List.of("Kode Kelas", "Program Studi", "Jumlah Mahasiswa");
    }

    @Override
    public List<String> getTableRowData() {
        return List.of(
            getCode(),
            (prodi != null ? prodi.getName() : "-"),
            String.valueOf(mahasiswaList.size())
        );
    }

    // --- Implementasi Persistable ---
    @Override
    public String toPersistableFormat() {
        String base = super.toPersistableFormat();
        String prodiCode = (prodi != null) ? prodi.getCode() : "null";
        return base + "," + prodiCode;
    }
}package id.ac.polban.model;

import java.util.List;
import java.util.Objects;

public class Mahasiswa extends Person {
    private Kelas kelas;

    public Mahasiswa(String nim, String nama, Kelas kelas) {
        super(nim, nama);
        this.kelas = kelas;
    }

    public Kelas getKelas() {
        return kelas;
    }

    public void setKelas(Kelas kelas) {
        this.kelas = kelas;
    }

    // --- info lebih detail ---
    @Override
    public String getIdentity() {
        String baseIdentity = super.getIdentity();
        return kelas != null ? baseIdentity + " | Kelas: " + kelas.getCode() : baseIdentity;
    }

    // --- Implementasi Displayable ---
    @Override
    public List<String> getTableHeader() {
        return List.of("NIM", "Nama Mahasiswa", "Kelas", "Status");
    }

    @Override
    public List<String> getTableRowData() {
        return List.of(
            getId(),
            getName(),
            (kelas != null ? kelas.getCode() : "-"),
            (isActive() ? "Aktif" : "Non-Aktif")
        );
    }

    // --- Implementasi Persistable ---
    @Override
    public String toPersistableFormat() {
        String personData = super.toPersistableFormat();
        String kelasId = (kelas != null) ? kelas.getCode() : "null";
        return personData + "," + kelasId;
    }
}
package id.ac.polban.model;

import id.ac.polban.contract.Activable;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

public class MataKuliah extends AkademikEntity implements Activable {
    private int sks;
    private CourseType courseType;
    private boolean activeStatus;
    private final List<Prodi> prodiList = new ArrayList<>();
    private final List<Dosen> pengampuList = new ArrayList<>();

    public MataKuliah(String courseCode, String courseName, int sks, CourseType courseType) {
        super(courseCode, courseName);
        this.sks = sks;
        this.courseType = Objects.requireNonNull(courseType);
        this.activeStatus = false;
    }

    // --- Getters & Setters ---
    public int getSks() { return sks; }
    public void setSks(int sks) { this.sks = sks; }
    public CourseType getCourseType() { return courseType; }

    // --- Logika Bisnis Relasi ---
    public List<Prodi> getProdiList() { return Collections.unmodifiableList(prodiList); }
    public void addProdi(Prodi prodi) { if (prodi != null && !prodiList.contains(prodi)) prodiList.add(prodi); }
    public void removeProdi(Prodi prodi) { prodiList.remove(prodi); }
    public List<Dosen> getPengampuList() { return Collections.unmodifiableList(pengampuList); }
    void tambahPengampu(Dosen dosen) { if (dosen != null && !pengampuList.contains(dosen)) pengampuList.add(dosen); }
    void hapusPengampu(Dosen dosen) { pengampuList.remove(dosen); }

    // --- Implementasi Interface Activable ---
    @Override
    public void activate() { this.activeStatus = true; }
    @Override
    public void deactivate() { this.activeStatus = false; }
    @Override
    public boolean isActive() { return activeStatus; }

    // --- Implementasi Displayable ---
    @Override
    public List<String> getTableHeader() {
        return List.of("Kode MK", "Nama Mata Kuliah", "SKS", "Tipe", "Status", "Prodi Terkait");
    }

    @Override
    public List<String> getTableRowData() {
        String prodiInfo = prodiList.stream().map(Prodi::getAlias).collect(Collectors.joining(", "));
        if (courseType == CourseType.UMUM) prodiInfo = "UMUM";
        if (prodiInfo.isEmpty()) prodiInfo = "-";

        return List.of(
            getCode(),
            getName(),
            String.valueOf(sks),
            courseType.toString(),
            isActive() ? "Ditawarkan" : "Tidak Ditawarkan",
            prodiInfo
        );
    }

    // --- Implementasi Persistable ---
    @Override
    public String toPersistableFormat() {
        return super.toPersistableFormat() + "," + sks + "," + courseType + "," + activeStatus;
    }
}package id.ac.polban.model;

import id.ac.polban.contract.Activable;
import id.ac.polban.contract.Displayable;
import id.ac.polban.contract.Persistable;

import java.util.List;
import java.util.Objects;

/**
 * Fondasi buat semua entitas orang di sistem ini.
 * Dibuat abstract biar ga bisa sembarangan bikin object Person,
 * kan aneh kalo ada "orang" tapi gajelas dia Dosen atau Mahasiswa.
 */
public abstract class Person implements Displayable, Activable, Persistable {
    private String id; // bisa NIM, bisa NIP. yang penting unik
    private String name;
    private boolean activeStatus;

    public Person(String id, String name) {
        this.id = Objects.requireNonNull(id);
        this.name = Objects.requireNonNull(name);
        this.activeStatus = false; // defaultnya semua non-aktif dulu
    }

    // --- Getters & Setters ---
    public String getId() { return id; }
    public void setId(String id) { this.id = Objects.requireNonNull(id); }
    public String getName() { return name; }
    public void setName(String name) { this.name = Objects.requireNonNull(name); }

    public String getIdentity() { return id + " - " + name; }

    // --- Implementasi Interface Activable ---
    @Override
    public void activate() { this.activeStatus = true; }
    @Override
    public void deactivate() { this.activeStatus = false; }
    @Override
    public boolean isActive() { return activeStatus; }

    // --- Implementasi Interface Persistable ---
    @Override
    public String toPersistableFormat() {
        return id + "," + name + "," + activeStatus;
    }

    // --- Override Method Bawaan Java ---
    @Override
    public String toString() { return getIdentity(); }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return id.equals(person.id);
    }

    @Override
    public int hashCode() { return id.hashCode(); }
}
package id.ac.polban.model;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Prodi extends AkademikEntity {
    private Jurusan jurusan;
    private String alias;
    private String jenjang;
    private final List<Kelas> classList = new ArrayList<>();
    private final List<MataKuliah> courseList = new ArrayList<>();

    public Prodi(String code, String name) {
        super(code, name);
    }

    public Prodi(String code, String name, String alias, String jenjang) {
        super(code, name);
        this.alias = alias;
        this.jenjang = jenjang;
    }

    // --- Getters & Setters ---
    public Jurusan getJurusan() { return jurusan; }
    void setJurusan(Jurusan jurusan) { this.jurusan = jurusan; }
    public String getAlias() { return alias; }
    public void setAlias(String alias) { this.alias = alias; }
    public String getJenjang() { return jenjang; }
    public void setJenjang(String jenjang) { this.jenjang = jenjang; }

    // --- Logika Bisnis ---
    public List<Kelas> getClassList() { return Collections.unmodifiableList(classList); }
    public void addKelas(Kelas kelas) {
        if (kelas != null && !classList.contains(kelas)) {
            classList.add(kelas);
            if (kelas.getProdi() != this) kelas.setProdi(this);
        }
    }
    public void removeKelas(Kelas kelas) {
        if (kelas != null && classList.remove(kelas)) {
            if (kelas.getProdi() == this) kelas.setProdi(null);
        }
    }
    public List<MataKuliah> getCourseList() { return Collections.unmodifiableList(courseList); }
    public void addMataKuliah(MataKuliah mk) {
        if (mk != null && mk.getCourseType() == CourseType.PRODI_SPECIFIC && !courseList.contains(mk)) {
            courseList.add(mk);
            mk.addProdi(this);
        }
    }
    public void removeMataKuliah(MataKuliah mk) {
        if (mk != null && courseList.remove(mk)) {
            mk.removeProdi(this);
        }
    }

    // --- Info Lebih Detail ---
    @Override
    public String getIdentity() {
        String base = super.getIdentity();
        String extra = "";
        if (alias != null && !alias.isEmpty()) extra += " | Alias: " + alias;
        if (jenjang != null && !jenjang.isEmpty()) extra += " | Jenjang: " + jenjang;
        if (jurusan != null) extra += " | Jurusan: " + jurusan.getName();
        return base + extra;
    }

    // --- Implementasi Displayable ---
    @Override
    public List<String> getTableHeader() {
        return List.of("Kode Prodi", "Nama Prodi", "Jenjang", "Jurusan");
    }

    @Override
    public List<String> getTableRowData() {
        return List.of(
            getCode(),
            getName(),
            (jenjang != null ? jenjang : "-"),
            (jurusan != null ? jurusan.getName() : "-")
        );
    }

    // --- Implementasi Persistable ---
    @Override
    public String toPersistableFormat() {
        String base = super.toPersistableFormat();
        String jurusanCode = (jurusan != null) ? jurusan.getCode() : "null";
        return base + "," + alias + "," + jenjang + "," + jurusanCode;
    }
}
package id.ac.polban.service;

import id.ac.polban.model.Jadwal;
import id.ac.polban.model.Kelas;

import java.time.DayOfWeek;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Locale;
import java.util.Optional;
import java.util.stream.Collectors;

public final class JadwalSearch {
    private JadwalSearch() {}

    /**
     * REFACTOR: Method ini sekarang MENGEMBALIKAN list jadwal, bukan mencetak.
     * Ini memisahkan logika pencarian data dari logika presentasi.
     */
    public static List<Jadwal> searchByKelas(Seed seed, String kodeKelas, String hariArg) {
        Optional<Kelas> opt = seed.getKelas().stream()
                .filter(k -> k.getCode().equalsIgnoreCase(kodeKelas))
                .findFirst();

        if (opt.isEmpty()) {
            System.out.printf("Kelas dengan kode '%s' tidak ditemukan.%n", kodeKelas);
            return Collections.emptyList(); // kembalikan list kosong
        }
        Kelas kelas = opt.get();

        List<Jadwal> source = kelas.getJadwalList();
        if (source.isEmpty()) {
            return Collections.emptyList();
        }

        // filter berdasarkan hari
        if (!"all".equalsIgnoreCase(hariArg)) {
            DayOfWeek target = parseHari(hariArg);
            if (target == null) {
                System.out.printf("Hari '%s' tidak dikenali.%n", hariArg);
                return Collections.emptyList();
            }
            source = source.stream().filter(j -> j.getDay() == target).collect(Collectors.toList());
        }

        // urutkan dan kembalikan hasilnya
        return source.stream()
                .sorted(Comparator.comparing(Jadwal::getDay).thenComparing(Jadwal::getStartTime))
                .collect(Collectors.toList());
    }

    private static DayOfWeek parseHari(String s) {
        if (s == null) return null;
        String x = s.trim().toLowerCase(Locale.ROOT);
        switch (x) {
            case "senin": return DayOfWeek.MONDAY;
            case "selasa": return DayOfWeek.TUESDAY;
            case "rabu": return DayOfWeek.WEDNESDAY;
            case "kamis": return DayOfWeek.THURSDAY;
            case "jumat": case "jum'at": return DayOfWeek.FRIDAY;
            case "sabtu": return DayOfWeek.SATURDAY;
            case "minggu": case "ahad": return DayOfWeek.SUNDAY;
        }
        try {
            return DayOfWeek.valueOf(x.toUpperCase(Locale.ROOT));
        } catch (IllegalArgumentException ignored) {}
        return null;
    }
}
package id.ac.polban.service;

import id.ac.polban.model.*;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.DayOfWeek;
import java.time.LocalTime;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public final class Seed {
    private final List<Dosen> dosen;
    private final List<MataKuliah> mataKuliah;
    private final List<Kelas> kelas;
    private final List<Mahasiswa> mahasiswa;
    private final List<Kampus> kampus;
    private final List<Jurusan> jurusan;
    private final List<Prodi> prodi;

    public Seed(
            List<Dosen> dosen, List<MataKuliah> mataKuliah, List<Kelas> kelas, List<Mahasiswa> mahasiswa,
            List<Kampus> kampus, List<Jurusan> jurusan, List<Prodi> prodi) {
        this.dosen = dosen;
        this.mataKuliah = mataKuliah;
        this.kelas = kelas;
        this.mahasiswa = mahasiswa;
        this.kampus = kampus;
        this.jurusan = jurusan;
        this.prodi = prodi;
    }

    // --- Getters ---
    public List<Dosen> getDosen() { return dosen; }
    public List<MataKuliah> getMataKuliah() { return mataKuliah; }
    public List<Kelas> getKelas() { return kelas; }
    public List<Mahasiswa> getMahasiswa() { return mahasiswa; }
    public List<Kampus> getKampus() { return kampus; }
    public List<Jurusan> getJurusan() { return jurusan; }
    public List<Prodi> getProdi() { return prodi; }

    public static Seed loadFromCsvs(String basePath) throws IOException {
        Map<String, Dosen> dosenMap = readDosenCsv(basePath);
        List<Kampus> kampus = readKampusCsvIfExists(basePath);
        Map<String, Jurusan> jurusanMap = readJurusanCsvIfExists(basePath, kampus);
        Map<String, Prodi> prodiMap = readProdiCsvIfExists(basePath, jurusanMap);
        Map<String, MataKuliah> mataKuliahMap = readMataKuliahCsv(basePath);

        // Hubungkan MataKuliah dengan Prodi
        List<Map.Entry<String, String>> mataKuliahProdiMappings = readMataKuliahProdiMapping(basePath);
        for (Map.Entry<String, String> entry : mataKuliahProdiMappings) {
            MataKuliah mk = mataKuliahMap.get(entry.getKey());
            Prodi prodi = prodiMap.get(entry.getValue());
            if (mk != null && prodi != null) {
                
                if (mk.getCourseType() == CourseType.PRODI_SPECIFIC) {
                    prodi.addMataKuliah(mk);
                } else {
                    System.err.printf("Peringatan: Mata Kuliah '%s' (tipe UMUM) tidak boleh punya asosiasi prodi. Melewati.%n", mk.getCode());
                }
            }
        }

        Map<String, String> kelasProdiMapping = readKelasProdiMapping(basePath);
        Map<String, Kelas> kelasMap = readJadwalCsv(basePath, dosenMap, mataKuliahMap, prodiMap, kelasProdiMapping);
        List<Mahasiswa> mahasiswaList = readMahasiswaCsv(basePath, kelasMap);

        // NOTE: Logika aktivasi (activateEntities) dihapus karena terlalu kompleks dan
        // tidak sesuai lagi dengan desain baru. Status aktif/non-aktif sekarang bisa
        // di-set langsung dari data CSV jika diperlukan, atau diabaikan.
        return new Seed(
                new ArrayList<>(dosenMap.values()), new ArrayList<>(mataKuliahMap.values()),
                new ArrayList<>(kelasMap.values()), mahasiswaList, kampus,
                new ArrayList<>(jurusanMap.values()), new ArrayList<>(prodiMap.values()));
    }

    private static Map<String, Dosen> readDosenCsv(String basePath) throws IOException {
        List<String> lines = Files.readAllLines(Paths.get(basePath, "dosen.csv"));
        Map<String, Dosen> dosenMap = new HashMap<>();
        for (int i = 1; i < lines.size(); i++) {
            String[] parts = lines.get(i).split(",");
            if (parts.length < 3) continue;
            Dosen d = new Dosen(parts[0].trim(), parts[1].trim(), parts[2].trim());
            
            dosenMap.put(d.getId(), d);
        }
        return dosenMap;
    }

    private static Map<String, MataKuliah> readMataKuliahCsv(String basePath) throws IOException {
        List<String> lines = Files.readAllLines(Paths.get(basePath, "matakuliah.csv"));
        Map<String, MataKuliah> mataKuliahMap = new HashMap<>();
        for (int i = 1; i < lines.size(); i++) {
            String[] parts = lines.get(i).split(",");
            if (parts.length < 4) continue;
            String kodeMk = parts[0].trim();
            String namaMk = parts[1].trim();
            int sks = Integer.parseInt(parts[2].trim());
            CourseType tipeMataKuliah = CourseType.valueOf(parts[3].trim().toUpperCase());
            MataKuliah mk = new MataKuliah(kodeMk, namaMk, sks, tipeMataKuliah);
            
            mataKuliahMap.put(mk.getCode(), mk);
        }
        return mataKuliahMap;
    }

    private static Map<String, Kelas> readJadwalCsv(
            String basePath, Map<String, Dosen> dosenMap, Map<String, MataKuliah> mataKuliahMap,
            Map<String, Prodi> prodiMap, Map<String, String> kelasProdiMapping) throws IOException {
        Map<String, Kelas> kelasMap = new HashMap<>();
        List<String> lines = Files.readAllLines(Paths.get(basePath, "jadwal.csv"));
        for (int i = 1; i < lines.size(); i++) {
            String[] parts = lines.get(i).split(",");
            if (parts.length < 7) continue;
            String kodeKelas = parts[0].trim();
            String kodeMk = parts[1].trim();
            String kodeDosen = parts[2].trim();

            MataKuliah mk = mataKuliahMap.get(kodeMk);
            Dosen dosen = dosenMap.get(kodeDosen);
            Prodi prodi = prodiMap.get(kelasProdiMapping.get(kodeKelas));

            if (mk == null || dosen == null || prodi == null) continue;

            Prodi finalProdi = prodi;
            Kelas kelas = kelasMap.computeIfAbsent(kodeKelas, k -> {
                Kelas newKelas = new Kelas(k, finalProdi);
                
                finalProdi.addKelas(newKelas);
                return newKelas;
            });

            DayOfWeek hari = DayOfWeek.valueOf(parts[3].trim().toUpperCase());
            LocalTime jamMulai = LocalTime.parse(parts[4].trim());
            LocalTime jamSelesai = LocalTime.parse(parts[5].trim());
            String ruangan = parts[6].trim();

            new Jadwal(kelas, mk, dosen, hari, jamMulai, jamSelesai, ruangan);
            dosen.ampu(mk);
        }
        return kelasMap;
    }

    private static List<Mahasiswa> readMahasiswaCsv(String basePath, Map<String, Kelas> kelasMap) throws IOException {
        List<String> lines = Files.readAllLines(Paths.get(basePath, "mahasiswa.csv"));
        List<Mahasiswa> allMahasiswa = new ArrayList<>();
        for (int i = 1; i < lines.size(); i++) {
            String[] parts = lines.get(i).split(",");
            if (parts.length < 3) continue;
            String nim = parts[0].trim();
            String nama = parts[1].trim();
            String kodeKelas = parts[2].trim();
            Kelas kelas = kelasMap.get(kodeKelas);
            if (kelas == null) continue;

            Mahasiswa m = new Mahasiswa(nim, nama, kelas);
            allMahasiswa.add(m);

            kelas.addMahasiswa(m);
        }
        return allMahasiswa;
    }

    private static List<Kampus> readKampusCsvIfExists(String basePath) throws IOException {
        Path p = Paths.get(basePath, "kampus.csv");
        List<Kampus> list = new ArrayList<>();
        if (!Files.exists(p)) return list;
        List<String> lines = Files.readAllLines(p);
        for (int i = 1; i < lines.size(); i++) {
            String[] parts = lines.get(i).split(",");
            if (parts.length < 3) continue;
            list.add(new Kampus(parts[0].trim(), parts[1].trim(), parts[2].trim()));
        }
        return list;
    }

    private static Map<String, Jurusan> readJurusanCsvIfExists(String basePath, List<Kampus> kampusList) throws IOException {
        Path p = Paths.get(basePath, "jurusan.csv");
        Map<String, Jurusan> map = new HashMap<>();
        if (!Files.exists(p)) return map;
        Map<String, Kampus> kampusMap = new HashMap<>();
        
        for (Kampus k : kampusList) kampusMap.put(k.getCode(), k);
        List<String> lines = Files.readAllLines(p);
        for (int i = 1; i < lines.size(); i++) {
            String[] parts = lines.get(i).split(",");
            if (parts.length < 4) continue;
            String kode = parts[0].trim();
            String nama = parts[1].trim();
            String alias = parts[2].trim();
            String kodeKampus = parts[3].trim();
            Kampus k = kampusMap.get(kodeKampus);
            if (k == null) continue;
            Jurusan j = new Jurusan(kode, nama, alias, k);
            k.addJurusan(j);
            map.put(kode, j);
        }
        return map;
    }

    private static Map<String, Prodi> readProdiCsvIfExists(String basePath, Map<String, Jurusan> jurusanMap) throws IOException {
        Path p = Paths.get(basePath, "prodi.csv");
        Map<String, Prodi> map = new HashMap<>();
        if (!Files.exists(p)) return map;
        List<String> lines = Files.readAllLines(p);
        for (int i = 1; i < lines.size(); i++) {
            String[] parts = lines.get(i).split(",");
            if (parts.length < 5) continue;
            String kode = parts[0].trim();
            String nama = parts[1].trim();
            String alias = parts[2].trim();
            String jenjang = parts[3].trim();
            String kodeJurusan = parts[4].trim();
            Jurusan j = jurusanMap.get(kodeJurusan);
            if (j == null) continue;
            Prodi pr = new Prodi(kode, nama, alias, jenjang);
            
            j.addProdi(pr);
            map.put(kode, pr);
        }
        return map;
    }

    private static Map<String, String> readKelasProdiMapping(String basePath) throws IOException {
        Path p = Paths.get(basePath, "kelas_prodi.csv");
        Map<String, String> map = new HashMap<>();
        if (!Files.exists(p)) return map;
        List<String> lines = Files.readAllLines(p);
        for (int i = 1; i < lines.size(); i++) {
            String[] parts = lines.get(i).split(",");
            if (parts.length < 2) continue;
            map.put(parts[0].trim(), parts[1].trim());
        }
        return map;
    }

    private static List<Map.Entry<String, String>> readMataKuliahProdiMapping(String basePath) throws IOException {
        Path p = Paths.get(basePath, "matakuliah_prodi.csv");
        List<Map.Entry<String, String>> mappings = new ArrayList<>();
        if (!Files.exists(p)) return mappings;
        List<String> lines = Files.readAllLines(p);
        for (int i = 1; i < lines.size(); i++) {
            String[] parts = lines.get(i).split(",");
            if (parts.length < 2) continue;
            mappings.add(new AbstractMap.SimpleEntry<>(parts[0].trim(), parts[1].trim()));
        }
        return mappings;
    }
}
